# Tools & MCPs Assessment

An evidence-based look at the three most useful tools in the AI-assisted development workflow, ranked by how well they integrate and how much they actually get used.

---

## 1. GitHub `gh` CLI — Absolute Essential

The `gh` CLI is the invisible backbone of the entire workflow. It's what turns Claude from a code writer into a full participant in the GitHub development cycle.

### Evidence

- **143+ PRs created** — the vast majority carry the `Generated with [Claude Code]` footer, meaning Claude used `gh pr create` with a HEREDOC template
- **PR descriptions are structured and consistent** — `## Summary` / `## Test plan` format across dozens of PRs, generated by Claude and passed to `gh pr create`
- **CI debugging loop** — when CI fails, Claude receives the failed action link and investigates via `gh run view` and `gh api`. Three CI fix commits confirm this loop:
  - `fix: resolve CI build warnings`
  - `fix: Fix E2E test failures in CI`
  - `fix: Add workflow_call trigger to CI workflow for reusable workflow support`
- **Branch + PR + merge in one session** — the feature implementation pattern depends entirely on `git` + `gh` for the branch-commit-push-PR-merge cycle

### Why It's Essential

Without `gh`, every PR would require a context switch to the browser. It closes the loop between code generation and the GitHub workflow. No configuration was needed beyond having `gh` authenticated — it just works.

---

## 2. Playwright MCP — Made Manual Testing by Claude Possible

Playwright MCP lets Claude open a browser, navigate the running application, interact with UI elements, take screenshots, and verify its own work visually. This is a genuinely novel workflow.

### Evidence

- **83 screenshot artifacts** in `.playwright-mcp/` spanning 7+ weeks of usage (Dec 7, 2025 – Jan 23, 2026)
- **11 implementation stories** explicitly reference Playwright MCP for manual verification:

| Story | Verification |
|-------|-------------|
| 7-1 Mobile Logout | "Manual verification performed using Playwright MCP" |
| 7-2 Profile Display | Screenshot saved to `.playwright-mcp/7-2-profile-display-verification.png` |
| 7-3 Year Selection | "Task 4 Complete: Manual verification with Playwright MCP" |
| 7-4 Expense Sorting | Screenshot saved to `.playwright-mcp/property-detail-with-dates.png` |
| 8.5-2 Sidebar Styling | "Visual verification screenshots saved to `.playwright-mcp/` folder" |
| 8.5-3 Logo/Favicon | "Visual verification completed via Playwright MCP" |
| 8.5-5 Visual Polish | 12 screenshots captured across desktop, mobile, and tablet viewports |
| 8-8 Delete Vendor | "Playwright MCP could not launch due to existing Chrome browser session conflict" |
| 8-9 Vendor Detail | "Task 7: E2E Tests - Verified with Playwright MCP" |
| 9-6 Work Order Dashboard | "Manual verification completed via Playwright MCP" |
| 13-4 Photo Gallery Fix | "Manual verification via Playwright MCP confirmed all AC met" |

- **The Dev Agent mandate is explicit** — `_bmad/bmm/agents/dev.md` line 73 says Playwright MCP is **"MANDATORY for frontend work"**: Claude must visually verify ALL UI changes before marking tasks complete
- **Screenshot categories show real QA work**: bug verification (`bug1-button-overflow-top.png`), responsive testing (`mobile-dashboard.png`, `tablet-view.png`), fix verification (`fix-verification-dashboard-mobile.png`), and a full 12-screenshot visual QA suite
- **Story 8-8 documents a failure**: "could not launch due to existing Chrome browser session conflict" — real usage, not theater
- **Complements automated E2E**: 14 Playwright spec files run in CI separately. The MCP is for ad-hoc visual verification during development

### Why It Works

It works because the agent configuration makes it MANDATORY. Claude doesn't just write frontend code — it opens the app, looks at it, and proves the UI matches the acceptance criteria.

---

## 3. Ref MCP — Underutilized, Requires Prompting

The Ref MCP tool searches documentation for libraries, frameworks, and APIs. In theory it should be used proactively. In practice, Claude rarely uses it without being explicitly told to.

### Evidence of Configuration

The instruction exists in the Dev Agent memory (`_bmad/bmm/agents/dev.md`, line 76):

> "Ref MCP is CRITICAL — use mcp__Ref__ref_search_documentation PROACTIVELY at story start AND during implementation. Research Angular, .NET, NPM, NuGet docs. Documentation lookups are cheaper than bugs."

Six agents total have Ref MCP instructions in their memories:

| Agent | Instruction Level |
|-------|------------------|
| Dev (Amelia) | "CRITICAL — use PROACTIVELY" |
| Architect (Winston) | "available for documentation lookup" |
| Quick Flow Solo Dev (Barry) | "available for documentation lookup" |
| Tech Writer (Paige) | "verify accuracy against official docs" |
| Test Architect (Murat) | "search Playwright, Cypress, Vitest, xUnit docs" |
| Scrum Master (Bob) | "available for documentation lookup" |

### Evidence of Non-Usage

| Area | Evidence |
|------|----------|
| Implementation artifacts (120+ files) | Zero references to documentation lookups being performed |
| Git commit history | No commits mention documentation research |
| Story 12.1 (QuestPDF) | Uses QuestPDF 2025.12.3 — no evidence of checking QuestPDF docs |
| Story 8.5.1 (Angular Material M3) | Migrates to M3 theming — no evidence of checking Angular Material docs |
| CLAUDE.md (always-loaded context) | Does not mention Ref MCP at all |

### The Disconnect

The tech stack includes 10+ libraries with rich documentation that Ref could look up:

- Angular Material
- QuestPDF
- MediatR
- EF Core
- NSwag
- SignalR
- FluentValidation
- @ngrx/signals
- Vitest
- Playwright

None of the 120+ story artifacts reference consulting official docs for any of these.

### Why It Doesn't Work (Yet)

The agent memories say "use it proactively" but that instruction competes with everything else in the agent context. CLAUDE.md — the file that's always loaded — omits Ref entirely. There's no reinforcement at the project level. Instructions buried in agent memories get lost; instructions in always-loaded context get followed.

---

## The Gradient

These three tools represent three different integration outcomes:

| Tool | Integration | Actual Usage | Lesson |
|------|-------------|-------------|--------|
| `gh` CLI | Built into Claude Code | Seamless, every PR | Essential infrastructure — no configuration needed |
| Playwright MCP | Configured + mandated in agent | Extensive, 83 artifacts | Works when you make it MANDATORY and the agent checks its own work |
| Ref MCP | Configured + instructed in agent | Underutilized | Instructions alone aren't enough — needs reinforcement in always-loaded context |

The gradient from "just works" to "needs prompting" tells a story about how to get the most out of AI tooling. The closer the instruction is to the always-loaded context, the more reliably it gets followed.
